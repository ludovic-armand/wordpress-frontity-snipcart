"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const eventPromised_1 = require("../utils/eventPromised");
const steps_1 = require("../steps");
const utils_1 = require("../utils");
const defaultOptions = {
    path: process.cwd(),
    typescript: false,
    noGit: false,
    packages: [],
    theme: "@frontity/mars-theme",
};
/**
 * The create command, exported to be used programatically.
 *
 * @param options - The options of the create command. Defined by {@link
 * CreateCommandOptions}.
 *
 * @returns An instance of {@link EventPromised}, which is a promise that can
 * also send events using an EventEmitter.
 */
exports.default = (options) => 
// EventPromised is a combination of EventEmitter and Promise.
new eventPromised_1.EventPromised((resolve, reject, emit) => {
    // Run an async action to be able to use `await`.
    (async () => {
        let step;
        let dirExisted;
        // Parses and validates options.
        const { name, theme, path, typescript, noGit } = (0, steps_1.normalizeOptions)(defaultOptions, options);
        process.on("SIGINT", async () => {
            if (typeof dirExisted !== "undefined")
                await (0, steps_1.revertProgress)(dirExisted, path);
        });
        try {
            // Ensures that the project dir exists and is empty.
            step = (0, steps_1.ensureProjectDir)(path);
            emit("message", `Ensuring ${chalk_1.default.yellow(path)} directory.`, step);
            dirExisted = await step;
            // Creates `README.md`
            step = (0, steps_1.createReadme)(name, path);
            emit("message", `Creating ${chalk_1.default.yellow("README.md")}.`, step);
            await step;
            // Creates `package.json`.
            step = (0, steps_1.createPackageJson)(name, theme, path, typescript);
            emit("message", `Creating ${chalk_1.default.yellow("package.json")}.`, step);
            await step;
            // Creates `frontity.settings`.
            const extension = typescript ? "ts" : "js";
            step = (0, steps_1.createFrontitySettings)(extension, name, path, theme);
            emit("message", `Creating ${chalk_1.default.yellow(`frontity.settings.${extension}`)}.`, step);
            await step;
            // Creates `tsconfig.json`.
            if (typescript) {
                step = (0, steps_1.createTsConfig)(path);
                emit("message", `Creating ${chalk_1.default.yellow("tsconfig.json")}.`, step);
                await step;
            }
            // Clones the theme inside `packages`.
            step = (0, steps_1.cloneStarterTheme)(theme, path);
            emit("message", `Cloning ${chalk_1.default.green(theme)}.`, step);
            await step;
            // Installs dependencies.
            step = (0, steps_1.installDependencies)(path);
            emit("message", `Installing dependencies.`, step);
            await step;
            // Download favicon.
            step = (0, steps_1.downloadFavicon)(path);
            emit("message", `Downloading ${chalk_1.default.yellow("favicon.ico")}.`, step);
            await step;
            // Run this step if `noGit` is false and if git is installed on user's machine
            if (!noGit && (0, utils_1.hasGit)()) {
                const gitignoreCleanup = await (0, steps_1.createGitignore)(path);
                if ((0, utils_1.isInGitRepository)()) {
                    emit("message", "Already in a git repository. Skipping initialization of a new git repo.", step);
                }
                else {
                    step = (0, steps_1.initializeGit)(path);
                    emit("message", `Initializing git repo.`, step);
                    try {
                        await step;
                    }
                    catch (e) {
                        await gitignoreCleanup();
                        emit("message", `Git initialization failed. Skipping...`, step);
                    }
                }
            }
        }
        catch (error) {
            if (typeof dirExisted !== "undefined")
                await (0, steps_1.revertProgress)(dirExisted, path);
            reject(error);
        }
    })().then(resolve);
});
