(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.hashIt = {}));
}(this, (function (exports) { 'use strict';

    /**
     * @constant __ placeholder used when parameters are skipped
     */
    var __ = typeof Symbol === 'function' ? Symbol('curriable placeholder') : 0xedd1;
    /**
     * @function recursiveCurry
     *
     * @description
     * recursively curry over the arguments until all have been resolved
     *
     * @param fn the function to curry
     * @param arity the length of the function to curry until
     * @param args the existing arguments
     * @returns the result of the function call
     */
    function getCurried(fn, arity) {
        function _curried(args) {
            return function () {
                var length = args.length;
                var newArgs = arguments;
                var newArgsLength = newArgs.length;
                var combined = [];
                var newArgsIndex = 0;
                var remaining = arity;
                var value;
                if (length) {
                    var index = -1;
                    while (++index < length) {
                        combined[index] = value =
                            args[index] === __ && newArgsIndex < newArgsLength
                                ? newArgs[newArgsIndex++]
                                : args[index];
                        if (value !== __) {
                            --remaining;
                        }
                    }
                }
                if (newArgsIndex < newArgsLength) {
                    while (newArgsIndex < newArgsLength) {
                        combined[combined.length] = value = newArgs[newArgsIndex];
                        if (value !== __ && newArgsIndex < arity) {
                            --remaining;
                        }
                        ++newArgsIndex;
                    }
                }
                return remaining > 0 ? _curried(combined) : fn.apply(this, combined);
            };
        }
        return _curried([]);
    }

    // utils
    function curry(fn, arityOverride) {
        var arity = typeof arityOverride === 'number' ? arityOverride : fn.length;
        var curried = getCurried(fn, arity);
        curried.arity = arity;
        curried.fn = fn;
        return curried;
    }
    curry.__ = __;
    /**
     * @function isPlaceholder
     *
     * @description
     * is the value passed a placeholder
     *
     * @param value the value to test
     * @returns whether the value is a placeholder
     */
    function isPlaceholder(value) {
        return value === __;
    }
    curry.isPlaceholder = isPlaceholder;
    /**
     * @function uncurry
     *
     * @description
     * return a function that is the non-curried version of the fn passed
     *
     * @param curried the curried function to uncurry
     * @returns the original fn
     */
    function uncurry(curried) {
        return curried.fn;
    }
    curry.uncurry = uncurry;

    var _SELF_TAGS, _TOSTRING_TAGS, _TYPEDARRAY_TAGS, _UNPARSEABLE_TAGS;

    /**
     * @constant {boolean} HAS_BUFFER_FROM_SUPPORT
     */
    var HAS_BUFFER_FROM_SUPPORT = typeof Buffer !== 'undefined' && typeof Buffer.from === 'function';
    /**
     * @constant {boolean} HAS_UINT16ARRAY_SUPPORT
     */

    var HAS_UINT16ARRAY_SUPPORT = typeof Uint16Array === 'function';
    /**
     * @constant {RegExp} HTML_ELEMENT_REGEXP
     */

    var HTML_ELEMENT_REGEXP = /\[object (HTML(.*)Element)\]/;
    /**
     * @constant {RegExp} SVG_ELEMENT_REGEXP
     */

    var SVG_ELEMENT_REGEXP = /\[object (SVG(.*)Element)\]/;
    /**
     * @constant {Array<string>} OBJECT_CLASSES
     */

    var OBJECT_CLASSES = ['Arguments', 'Array', 'ArrayBuffer', 'Boolean', 'DataView', 'Date', 'DocumentFragment', 'Error', 'Event', 'Float32Array', 'Float64Array', 'Function', 'Generator', 'GeneratorFunction', 'HTMLElement', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Null', 'Number', 'Object', 'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'Undefined', 'WeakMap', 'WeakSet', 'Window'];
    /**
     * @constant {Object} OBJECT_CLASS_MAP
     */

    var OBJECT_CLASS_MAP = OBJECT_CLASSES.reduce(function (objectClasses, type) {
      objectClasses["[object " + type + "]"] = type;
      return objectClasses;
    }, {});
    /**
     * @constant {Object} OBJECT_CLASS_TYPE_MAP
     */

    var OBJECT_CLASS_TYPE_MAP = Object.keys(OBJECT_CLASS_MAP).reduce(function (objectClassTypes, objectClass) {
      objectClassTypes[OBJECT_CLASS_MAP[objectClass].toUpperCase()] = objectClass;
      return objectClassTypes;
    }, {});
    var ITERABLE_TAGS = {
      '[object Map]': true,
      '[object Set]': true
    };
    var PRIMITIVE_TAGS = {
      boolean: true,
      function: true,
      number: true,
      string: true,
      undefined: true
    };
    var SELF_TAGS = (_SELF_TAGS = {}, _SELF_TAGS[OBJECT_CLASS_TYPE_MAP.ARGUMENTS] = true, _SELF_TAGS[OBJECT_CLASS_TYPE_MAP.ARRAY] = true, _SELF_TAGS);
    var TOSTRING_TAGS = (_TOSTRING_TAGS = {}, _TOSTRING_TAGS[OBJECT_CLASS_TYPE_MAP.REGEXP] = true, _TOSTRING_TAGS[OBJECT_CLASS_TYPE_MAP.SYMBOL] = true, _TOSTRING_TAGS);
    var TYPEDARRAY_TAGS = (_TYPEDARRAY_TAGS = {}, _TYPEDARRAY_TAGS[OBJECT_CLASS_TYPE_MAP.FLOAT32ARRAY] = true, _TYPEDARRAY_TAGS[OBJECT_CLASS_TYPE_MAP.FLOAT64ARRAY] = true, _TYPEDARRAY_TAGS[OBJECT_CLASS_TYPE_MAP.INT8ARRAY] = true, _TYPEDARRAY_TAGS[OBJECT_CLASS_TYPE_MAP.INT16ARRAY] = true, _TYPEDARRAY_TAGS[OBJECT_CLASS_TYPE_MAP.INT32ARRAY] = true, _TYPEDARRAY_TAGS[OBJECT_CLASS_TYPE_MAP.UINT8ARRAY] = true, _TYPEDARRAY_TAGS[OBJECT_CLASS_TYPE_MAP.UINT8CLAMPEDARRAY] = true, _TYPEDARRAY_TAGS[OBJECT_CLASS_TYPE_MAP.UINT16ARRAY] = true, _TYPEDARRAY_TAGS[OBJECT_CLASS_TYPE_MAP.UINT32ARRAY] = true, _TYPEDARRAY_TAGS);
    var UNPARSEABLE_TAGS = (_UNPARSEABLE_TAGS = {}, _UNPARSEABLE_TAGS[OBJECT_CLASS_TYPE_MAP.GENERATOR] = true, _UNPARSEABLE_TAGS[OBJECT_CLASS_TYPE_MAP.PROMISE] = true, _UNPARSEABLE_TAGS[OBJECT_CLASS_TYPE_MAP.WEAKMAP] = true, _UNPARSEABLE_TAGS[OBJECT_CLASS_TYPE_MAP.WEAKSET] = true, _UNPARSEABLE_TAGS);

    var FUNCTION_NAME_REGEX = /^\s*function\s*([^(]*)/i;
    var toString = Object.prototype.toString;
    var keys = Object.keys;
    /**
     * @function getFunctionName
     *
     * @description
     * get the name of the function based on a series of fallback attempts
     *
     * @param {function} fn the function to test
     * @returns {string} the function name
     */

    function getFunctionName(fn) {
      return fn.name || (fn.toString().match(FUNCTION_NAME_REGEX) || [])[1] || 'anonymous';
    }
    /**
     * @function getIntegerHashValue
     *
     * @description
     * based on string passed, get the integer hash value
     * through bitwise operation (based on spinoff of dbj2
     * with enhancements for reduced collisions)
     *
     * @param {string} string the string to get the hash value for
     * @returns {number} the hash value
     */

    function getIntegerHashValue(string) {
      var index = string.length,
          hashA = 5381,
          hashB = 52711,
          charCode;

      while (index--) {
        charCode = string.charCodeAt(index);
        hashA = hashA * 33 ^ charCode;
        hashB = hashB * 33 ^ charCode;
      }

      return (hashA >>> 0) * 4096 + (hashB >>> 0);
    }
    /**
     * @function getSortedEvent
     *
     * @description
     * get the event object sorted by its properties
     *
     * @param {boolean} bubbles does the event bubble up through the DOM
     * @param {function} alias to stopPropagation
     * @param {boolean} cancelable is the event cancelable
     * @param {boolean} composed can the event bubble across the boundary to shadow DOM
     * @param {HTMLElement} [currentTarget] registered target for the event
     * @param {boolean} defaultPrevented has preventDefault been called on the event
     * @param {string} eventPhase the phase of the event flow being processed
     * @param {boolean} isTrusted was the event initiated by the browser
     * @param {HTMLElement} [target] the target with which the event was dispatched
     * @param {number} timeStamp the time at which the event was created
     * @param {string} type the name of the event
     * @returns {Object} the event object with all properties sorted
     */

    function getSortedEvent(event) {
      return {
        bubbles: event.bubbles,
        cancelBubble: event.cancelBubble,
        cancelable: event.cancelable,
        composed: event.composed,
        currentTarget: event.currentTarget,
        defaultPrevented: event.defaultPrevented,
        eventPhase: event.eventPhase,
        isTrusted: event.isTrusted,
        returnValue: event.returnValue,
        target: event.target,
        type: event.type
      };
    }
    /**
     * @function shouldSort
     *
     * @description
     * get the sort result based on the two values to compare
     *
     * @param {string} valueA the first value to compare
     * @param {string} valueB the second value to compare
     * @returns {boolean} should the value be sorted
     */

    function shouldSort(valueA, valueB) {
      return valueA > valueB;
    }
    /**
     * @function shouldSortPair
     *
     * @description
     * get the sort result based on the two pairs to compare
     *
     * @param {Object} pairA the first pair to compare
     * @param {Object} pairB the second pair to compare
     * @returns {boolean} should the value be sorted
     */

    function shouldSortPair(pairA, pairB) {
      return pairA[0] > pairB[0];
    }
    /**
     * @function sort
     *
     * @description
     * sort the array based on the fn passed
     *
     * @param {Array<any>} array the array to sort
     * @param {function} fn the sorting function
     * @returns {Array<any>} the sorted array
     */

    function sort(array, fn) {
      var subIndex, value;

      for (var index = 0; index < array.length; ++index) {
        value = array[index];

        for (subIndex = index - 1; ~subIndex && fn(array[subIndex], value); --subIndex) {
          array[subIndex + 1] = array[subIndex];
        }

        array[subIndex + 1] = value;
      }

      return array;
    }
    /**
     * @function getIterablePairs
     *
     * @description
     * get the pairs in the iterable for stringification
     *
     * @param {Map|Set} iterable the iterable to get the pairs for
     * @returns {Array<{key: string, value: any}>} the pairs
     */

    function getSortedIterable(iterable, cache, keys) {
      var isMap = typeof iterable.get === 'function';
      var entries = [];

      if (isMap) {
        iterable.forEach(function (value, key) {
          entries.push([// eslint-disable-next-line no-use-before-define
          stringify(key, cache, keys), // eslint-disable-next-line no-use-before-define
          stringify(value, cache, keys)]);
        });
        sort(entries, shouldSortPair);
      } else {
        iterable.forEach(function (value) {
          // eslint-disable-next-line no-use-before-define
          entries.push(stringify(value, cache, keys));
        });
        sort(entries, shouldSort);
      }

      var _final = getFunctionName(iterable.constructor) + "|[";

      for (var index = 0, length = entries.length, entry; index < length; ++index) {
        entry = entries[index];
        _final += "" + (index ? ',' : '') + (isMap ? "[" + entry[0] + "," + entry[1] + "]" : entry);
      }

      return _final + "]";
    }
    /**
     * @function getSortedObject
     *
     * @description
     * get the object with the keys sorted
     *
     * @param {Object} object the object to sort
     * @returns {Object} the sorted object
     */

    function getSortedObject(object) {
      var objectKeys = sort(keys(object), shouldSort);
      var newObject = {};
      var key;

      for (var index = 0; index < objectKeys.length; ++index) {
        key = objectKeys[index];
        newObject[key] = object[key];
      }

      return newObject;
    }
    /**
     * @function getStringifiedArrayBufferFallback
     *
     * @description
     * get the string value of the buffer passed based on a Buffer
     *
     * @param {ArrayBuffer} buffer the array buffer to convert
     * @returns {string} the stringified buffer
     */

    function getStringifiedArrayBufferFallback(buffer) {
      return String.fromCharCode.apply(null, new Uint16Array(buffer));
    }
    /**
     * @function getStringifiedArrayBufferModern
     *
     * @description
     * get the string value of the buffer passed based on a Uint16Array
     *
     * @param {ArrayBuffer} buffer the array buffer to convert
     * @returns {string} the stringified buffer
     */

    function getStringifiedArrayBufferModern(buffer) {
      return Buffer.from(buffer).toString('utf8');
    }
    /**
     * @function getStringifiedArrayBufferNoSupport
     *
     * @description
     * return a placeholder when no arraybuffer support exists
     *
     * @returns {string} the placeholder
     */

    function getStringifiedArrayBufferNoSupport() {
      return '';
    }
    /**
     * @function getStringifiedArrayBuffer
     *
     * @description
     * get the string value of the buffer passed
     *
     * @param {ArrayBuffer} buffer the array buffer to convert
     * @returns {string} the stringified buffer
     */

    var getStringifiedArrayBuffer = function () {
      if (HAS_BUFFER_FROM_SUPPORT) {
        return getStringifiedArrayBufferModern;
      }

      if (HAS_UINT16ARRAY_SUPPORT) {
        return getStringifiedArrayBufferFallback;
      }

      return getStringifiedArrayBufferNoSupport;
    }();
    /**
     * @function getStringifiedDocumentFragment
     *
     * @description
     * build a string based on all the fragment's children
     *
     * @param {DocumentFragment} fragment the fragment to stringify
     * @returns {string} the stringified fragment
     */

    function getStringifiedDocumentFragment(fragment) {
      var children = fragment.children;
      var innerHTML = '';

      for (var index = 0; index < children.length; ++index) {
        innerHTML += children[index].outerHTML;
      }

      return innerHTML;
    }
    /**
     * @function getCutoffIndex
     *
     * @description
     * get the index after that of the value match in the array (faster than
     * native indexOf) to determine the cutoff index for the `splice()` call.
     *
     * @param {Array<any>} array the array to get the index of the value at
     * @param {any} value the value to match
     * @returns {number} the index after the value match in the array
     */

    function getCutoffIndex(array, value) {
      for (var index = 0; index < array.length; ++index) {
        if (array[index] === value) {
          return index + 1;
        }
      }

      return 0;
    }
    /**
     * @function getNormalizedValue
     *
     * @description
     * get the value normalized for stringification
     *
     * @param {any} value the value to normalize
     * @param {WeakMap|Object} sortedCache the cache of sorted objects
     * @param {string} [passedTag] the previously-calculated tag
     * @returns {any} the normalized value
     */

    function getNormalizedValue(value, cache, keys, passedTag) {
      if (passedTag === void 0) {
        var type = typeof value;

        if (type === 'string' || PRIMITIVE_TAGS[type]) {
          return type + "|" + value;
        }

        if (value === null) {
          return "null|" + value;
        }
      }

      var tag = passedTag || toString.call(value);

      if (SELF_TAGS[tag]) {
        return value;
      }

      if (tag === OBJECT_CLASS_TYPE_MAP.OBJECT) {
        return getSortedObject(value);
      }

      if (TOSTRING_TAGS[tag]) {
        return OBJECT_CLASS_MAP[tag] + "|" + value.toString();
      }

      if (ITERABLE_TAGS[tag]) {
        return getSortedIterable(value, cache, keys);
      }

      if (tag === OBJECT_CLASS_TYPE_MAP.DATE) {
        return OBJECT_CLASS_MAP[tag] + "|" + value.getTime();
      }

      if (tag === OBJECT_CLASS_TYPE_MAP.ERROR) {
        return OBJECT_CLASS_MAP[tag] + "|" + value.stack;
      }

      if (tag === OBJECT_CLASS_TYPE_MAP.EVENT) {
        return getSortedEvent(value);
      }

      if (UNPARSEABLE_TAGS[tag]) {
        return OBJECT_CLASS_MAP[tag] + "|NOT_ENUMERABLE";
      }

      if (HTML_ELEMENT_REGEXP.test(tag) || SVG_ELEMENT_REGEXP.test(tag)) {
        return tag.slice(8, -1) + "|" + value.outerHTML;
      }

      if (tag === OBJECT_CLASS_TYPE_MAP.DOCUMENTFRAGMENT) {
        return OBJECT_CLASS_MAP[tag] + "|" + getStringifiedDocumentFragment(value);
      }

      if (TYPEDARRAY_TAGS[tag]) {
        return OBJECT_CLASS_MAP[tag] + "|" + value.join(',');
      }

      if (tag === OBJECT_CLASS_TYPE_MAP.ARRAYBUFFER) {
        return OBJECT_CLASS_MAP[tag] + "|" + getStringifiedArrayBuffer(value);
      }

      if (tag === OBJECT_CLASS_TYPE_MAP.DATAVIEW) {
        return OBJECT_CLASS_MAP[tag] + "|" + getStringifiedArrayBuffer(value.buffer);
      }

      return value;
    }
    /**
     * @function replacer
     *
     * @description
     * create the replacer function used for stringification
     *
     * @param {WeakSet|Object} sortedCache the cache to use for sorting objects
     * @returns {function(key: string, value: any)} function getting the normalized value
     */

    function createReplacer(cache, keys) {
      if (cache === void 0) {
        cache = [];
      }

      if (keys === void 0) {
        keys = [];
      }

      return function (key, value) {
        if (typeof value === 'object') {
          if (cache.length) {
            var thisCutoff = getCutoffIndex(cache, this);

            if (thisCutoff === 0) {
              cache.push(this);
            } else {
              cache.splice(thisCutoff);
              keys.splice(thisCutoff);
            }

            keys.push(key);
            var valueCutoff = getCutoffIndex(cache, value);

            if (valueCutoff !== 0) {
              return "[~" + (keys.slice(0, valueCutoff).join('.') || '.') + "]";
            }

            cache.push(value);
          } else {
            cache[0] = value;
            keys[0] = key;
          }
        }

        if (key && this[key] instanceof Date) {
          return getNormalizedValue(this[key], cache, keys, OBJECT_CLASS_TYPE_MAP.DATE);
        }

        return getNormalizedValue(value, cache, keys);
      };
    }
    /**
     * @function stringify
     *
     * @description
     * stringify the value based on the options passed
     *
     * @param {any} value the value to stringify
     * @returns {string} the stringified value
     */

    function stringify(value, cache, keys) {
      if (!value || typeof value !== 'object') {
        return getNormalizedValue(value, cache, keys);
      }

      var tag = toString.call(value);

      if (tag === OBJECT_CLASS_TYPE_MAP.DATE || tag === OBJECT_CLASS_TYPE_MAP.REGEXP) {
        return getNormalizedValue(value, cache, keys, tag);
      }

      return JSON.stringify(value, createReplacer(cache, keys));
    }

    // external dependencies
    /**
     * @function hash
     *
     * @description
     * hash the value passed to a unique, consistent hash value
     *
     * @param {any} value the value to hash
     * @returns {number} the object hash
     */

    function hash(value) {
      return getIntegerHashValue(stringify(value));
    }
    /**
     * @function hash.is
     *
     * @description
     * create a comparator for the first object passed to determine if the second is equal
     *
     * @param {any} object the object to test against
     * @returns {function(any): boolean} the method to test against the object
     */

    hash.is = curry(function (object, otherObject) {
      return hash(object) === hash(otherObject);
    });
    /**
     * @function hash.is.all
     *
     * @description
     * determine if all of the objects passed are equal in value to the first
     *
     * @param {...Array<any>} objects the objects to test for equality
     * @returns {boolean} are the objects equal
     */

    hash.is.all = curry(function (objectBasis) {
      var isEqual = hash.is(objectBasis);

      for (var index = 1; index < arguments.length; ++index) {
        if (!isEqual(arguments[index])) {
          return false;
        }
      }

      return true;
    }, 2);
    /**
     * @function hash.is.any
     *
     * @description
     * determine if any of the objects passed are equal in value to the first
     *
     * @param {...Array<any>} objects the objects to test for equality
     * @returns {boolean} are the objects equal
     */

    hash.is.any = curry(function (objectBasis) {
      var isEqual = hash.is(objectBasis);

      for (var index = 1; index < arguments.length; index++) {
        if (isEqual(arguments[index])) {
          return true;
        }
      }

      return false;
    }, 2);
    /**
     * @function hash.is.not
     *
     * @description
     * create a comparator for the first object passed to determine if the second is not equal
     *
     * @param {any} object the object to test against
     * @returns {function(any): boolean} the method to test against the object
     */

    hash.is.not = curry(function (object, otherObject) {
      return hash(object) !== hash(otherObject);
    });

    exports.default = hash;
    exports.hash = hash;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=hash-it.js.map
