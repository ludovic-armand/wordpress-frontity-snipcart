"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const eventPromised_1 = require("../utils/eventPromised");
const path_1 = require("path");
const create_package_1 = require("../steps/create-package");
const steps_1 = require("../steps");
const createPackage = async (options, emit, reject) => {
    const emitMessage = (message, step) => {
        emit("message", message, step);
    };
    let step;
    let dirExisted;
    const { name, namespace, packagePath, projectPath } = options;
    process.on("SIGINT", async () => {
        if (typeof dirExisted !== "undefined")
            await (0, steps_1.revertProgress)(dirExisted, packagePath);
    });
    try {
        // 1. Create ./packages/[name] folder.
        step = (0, steps_1.ensureProjectDir)((0, path_1.join)(packagePath, "src"));
        emitMessage(`Creating ${chalk_1.default.yellow(packagePath)} folder.`, step);
        dirExisted = await step;
        // 2. Creates `package.json`.
        step = (0, create_package_1.createPackageJson)(name, namespace, projectPath, packagePath);
        emitMessage(`Adding ${chalk_1.default.yellow("package.json")}.`, step);
        await step;
        // 3. Creates `src/index.js`.
        step = (0, create_package_1.createSrcIndexJs)(name, namespace, projectPath, packagePath);
        emitMessage(`Adding ${chalk_1.default.yellow("src/index.js")}.`, step);
        await step;
        // 4. Install package
        step = (0, create_package_1.installPackage)(projectPath, packagePath);
        emitMessage(`Installing package ${chalk_1.default.yellow(name)}.`, step);
        await step;
    }
    catch (error) {
        if (typeof dirExisted !== "undefined") {
            await (0, steps_1.revertProgress)(dirExisted, packagePath);
        }
        reject(error);
    }
};
exports.default = (options) => 
// EventPromised is a combination of EventEmitter and Promise
new eventPromised_1.EventPromised((resolve, reject, emit) => {
    createPackage(options, emit, reject).then(resolve);
});
