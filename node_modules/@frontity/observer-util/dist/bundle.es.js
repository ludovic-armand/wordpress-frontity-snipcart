var connectionStore = new WeakMap();
var ITERATION_KEY = Symbol('iteration key');
function storeObservable(obj) {
  // this will be used to save (obj.key -> reaction) connections later
  connectionStore.set(obj, new Map());
}
function registerReactionForOperation(reaction, {
  target,
  key,
  type
}) {
  if (type === 'iterate') {
    key = ITERATION_KEY;
  }

  var reactionsForObj = connectionStore.get(target);
  var reactionsForKey = reactionsForObj.get(key);

  if (!reactionsForKey) {
    reactionsForKey = new Set();
    reactionsForObj.set(key, reactionsForKey);
  } // save the fact that the key is used by the reaction during its current run


  if (!reactionsForKey.has(reaction)) {
    reactionsForKey.add(reaction);
    reaction.cleaners.push(reactionsForKey);
  }
}
function getReactionsForOperation({
  target,
  key,
  type
}) {
  var reactionsForTarget = connectionStore.get(target);
  var reactionsForKey = new Set();

  if (type === 'clear') {
    reactionsForTarget.forEach((_, key) => {
      addReactionsForKey(reactionsForKey, reactionsForTarget, key);
    });
  } else {
    addReactionsForKey(reactionsForKey, reactionsForTarget, key);
  }

  if (type === 'add' || type === 'delete' || type === 'clear') {
    var iterationKey = Array.isArray(target) ? 'length' : ITERATION_KEY;
    addReactionsForKey(reactionsForKey, reactionsForTarget, iterationKey);
  }

  return reactionsForKey;
}

function addReactionsForKey(reactionsForKey, reactionsForTarget, key) {
  var reactions = reactionsForTarget.get(key);
  reactions && reactions.forEach(reactionsForKey.add, reactionsForKey);
}

function releaseReaction(reaction) {
  if (reaction.cleaners) {
    reaction.cleaners.forEach(releaseReactionKeyConnection, reaction);
  }

  reaction.cleaners = [];
}

function releaseReactionKeyConnection(reactionsForKey) {
  reactionsForKey.delete(this);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

var proxyToRaw = new WeakMap();
var rawToProxy = new WeakMap(); // stores custom proxy handlers for observables

var rawToOptions = new WeakMap();

// this is a copy of the built-in Reflect object
// Reflect keys are not enumerable, so a simple { ...Reflect } spread does not work here
// we have to copy all Reflect handlers to the object instead

var proxyHandlers = Object.freeze(Object.getOwnPropertyNames(Reflect).reduce((handlers, key) => _objectSpread2(_objectSpread2({}, handlers), {}, {
  [key]: Reflect[key]
}), {})); // ES6 collection method related handlers

var collectionHandlers = Object.freeze({
  has: (target, ...args) => target.has(...args),
  get: (target, ...args) => target.get(...args),
  add: (target, ...args) => target.add(...args),
  set: (target, ...args) => target.set(...args),
  delete: (target, ...args) => target.delete(...args),
  clear: (target, ...args) => target.clear(...args),
  forEach: (target, ...args) => target.forEach(...args),
  keys: (target, ...args) => target.keys(...args),
  values: (target, ...args) => target.values(...args),
  entries: (target, ...args) => target.entries(...args),
  [Symbol.iterator]: (target, ...args) => target[Symbol.iterator](...args),
  size: target => target.size
});
var reactionHandlers = Object.freeze({
  // order/filter reactions triggered by an atomic observable mutation
  transformReactions: (target, key, reactions) => reactions
});
var defaultHandlers = {
  proxyHandlers,
  collectionHandlers,
  reactionHandlers
};
var runProxyHandler = (...args) => runHandler('proxyHandlers', ...args);
var runCollectionHandler = (...args) => runHandler('collectionHandlers', ...args);
var runReactionHandler = (...args) => runHandler('reactionHandlers', ...args); // runs the default or custom (user-provided) handler for the specific operation

function runHandler(handlers, name, target, ...args) {
  var _options$handlers;

  var options = rawToOptions.get(target);
  var handler = (options === null || options === void 0 ? void 0 : (_options$handlers = options[handlers]) === null || _options$handlers === void 0 ? void 0 : _options$handlers[name]) || defaultHandlers[handlers][name];
  return handler(target, ...args);
}

var reactionStack = [];
var isDebugging = false;
function runAsReaction(reaction, fn, context, args) {
  // do not build reactive relations, if the reaction is unobserved
  if (reaction.unobserved) {
    return Reflect.apply(fn, context, args);
  } // only run the reaction if it is not already in the reaction stack
  // TODO: improve this to allow explicitly recursive reactions


  if (reactionStack.indexOf(reaction) === -1) {
    // release the (obj -> key -> reactions) connections
    // and reset the cleaner connections
    releaseReaction(reaction);

    try {
      // set the reaction as the currently running one
      // this is required so that we can create (observable.prop -> reaction) pairs in the get trap
      reactionStack.push(reaction);
      return Reflect.apply(fn, context, args);
    } finally {
      // always remove the currently running flag from the reaction when it stops execution
      reactionStack.pop();
    }
  }
} // register the currently running reaction to be queued again on obj.key mutations

function registerRunningReactionForOperation(operation) {
  // get the current reaction from the top of the stack
  var runningReaction = reactionStack[reactionStack.length - 1];

  if (runningReaction) {
    debugOperation(runningReaction, operation);
    registerReactionForOperation(runningReaction, operation);
  }
}
function queueReactionsForOperation(operation) {
  // iterate and queue every reaction, which is triggered by obj.key mutation
  var target = operation.target,
      key = operation.key;
  var reactions = getReactionsForOperation(operation);
  runReactionHandler('transformReactions', target, key, Array.from(reactions)).forEach(queueReaction, operation);
}

function queueReaction(reaction) {
  debugOperation(reaction, this); // queue the reaction for later execution or run it immediately

  if (typeof reaction.scheduler === 'function') {
    reaction.scheduler(reaction);
  } else if (typeof reaction.scheduler === 'object') {
    reaction.scheduler.add(reaction);
  } else {
    reaction();
  }
}

function debugOperation(reaction, operation) {
  if (reaction.debugger && !isDebugging) {
    try {
      isDebugging = true;
      reaction.debugger(operation);
    } finally {
      isDebugging = false;
    }
  }
}

var IS_REACTION = Symbol('is reaction');
function observe(fn, options = {}) {
  // wrap the passed function in a reaction, if it is not already one
  var reaction = fn[IS_REACTION] ? fn : function reaction() {
    return runAsReaction(reaction, fn, this, arguments);
  }; // save the scheduler and debugger on the reaction

  reaction.scheduler = options.scheduler;
  reaction.debugger = options.debugger; // save the fact that this is a reaction

  reaction[IS_REACTION] = true; // run the reaction once if it is not a lazy one

  if (!options.lazy) {
    reaction();
  }

  return reaction;
}
function unobserve(reaction) {
  // do nothing, if the reaction is already unobserved
  if (!reaction.unobserved) {
    // indicate that the reaction should not be triggered any more
    reaction.unobserved = true; // release (obj -> key -> reaction) connections

    releaseReaction(reaction);
  } // unschedule the reaction, if it is scheduled


  if (typeof reaction.scheduler === 'object') {
    reaction.scheduler.delete(reaction);
  }
}

function patchIterator(iterator, target, isEntries) {
  var originalNext = iterator.next;

  iterator.next = () => {
    var _originalNext$call = originalNext.call(iterator),
        done = _originalNext$call.done,
        value = _originalNext$call.value;

    if (!done) {
      if (isEntries) {
        value[1] = observableChild(value[1], target);
      } else {
        value = observableChild(value, target);
      }
    }

    return {
      done,
      value
    };
  };

  return iterator;
}

var collectionHandlers$1 = {
  has(key) {
    var target = proxyToRaw.get(this);
    registerRunningReactionForOperation({
      target,
      key,
      type: 'has'
    });
    return runCollectionHandler('has', target, ...arguments);
  },

  get(key) {
    var target = proxyToRaw.get(this);
    registerRunningReactionForOperation({
      target,
      key,
      type: 'get'
    });
    return observableChild(runCollectionHandler('get', target, ...arguments), target);
  },

  add(key) {
    var target = proxyToRaw.get(this);
    var hadKey = target.has(key); // forward the operation before queueing reactions

    var result = runCollectionHandler('add', target, ...arguments);

    if (!hadKey) {
      queueReactionsForOperation({
        target,
        key,
        value: key,
        type: 'add'
      });
    }

    return result;
  },

  set(key, value) {
    var target = proxyToRaw.get(this);
    var hadKey = target.has(key);
    var oldValue = target.get(key); // forward the operation before queueing reactions

    var result = runCollectionHandler('set', target, ...arguments);

    if (!hadKey) {
      queueReactionsForOperation({
        target,
        key,
        value,
        type: 'add'
      });
    } else if (value !== oldValue) {
      queueReactionsForOperation({
        target,
        key,
        value,
        oldValue,
        type: 'set'
      });
    }

    return result;
  },

  delete(key) {
    var target = proxyToRaw.get(this);
    var hadKey = target.has(key);
    var oldValue = target.get ? target.get(key) : undefined; // forward the operation before queueing reactions

    var result = runCollectionHandler('delete', target, ...arguments);

    if (hadKey) {
      queueReactionsForOperation({
        target,
        key,
        oldValue,
        type: 'delete'
      });
    }

    return result;
  },

  clear() {
    var target = proxyToRaw.get(this);
    var hadItems = target.size !== 0;
    var oldTarget = target instanceof Map ? new Map(target) : new Set(target); // forward the operation before queueing reactions

    var result = runCollectionHandler('clear', target, ...arguments);

    if (hadItems) {
      queueReactionsForOperation({
        target,
        oldTarget,
        type: 'clear'
      });
    }

    return result;
  },

  forEach(callback, ...args) {
    var target = proxyToRaw.get(this);
    registerRunningReactionForOperation({
      target,
      type: 'iterate'
    }); // swap out the raw values with their observable pairs
    // before passing them to the callback

    var wrappedCallback = (value, ...rest) => callback(observableChild(value, target), ...rest);

    return runCollectionHandler('forEach', target, wrappedCallback, ...args);
  },

  keys() {
    var target = proxyToRaw.get(this);
    registerRunningReactionForOperation({
      target,
      type: 'iterate'
    }); // TODO: no need to patch this?

    return runCollectionHandler('keys', target, ...arguments);
  },

  values() {
    var target = proxyToRaw.get(this);
    registerRunningReactionForOperation({
      target,
      type: 'iterate'
    });
    var iterator = runCollectionHandler('values', target, ...arguments);
    return patchIterator(iterator, target, false);
  },

  entries() {
    var target = proxyToRaw.get(this);
    registerRunningReactionForOperation({
      target,
      type: 'iterate'
    });
    var iterator = runCollectionHandler('entries', target, ...arguments);
    return patchIterator(iterator, target, true);
  },

  [Symbol.iterator]() {
    var target = proxyToRaw.get(this);
    registerRunningReactionForOperation({
      target,
      type: 'iterate'
    });
    var iterator = runCollectionHandler(Symbol.iterator, target, ...arguments);
    return patchIterator(iterator, target, target instanceof Map);
  },

  get size() {
    var target = proxyToRaw.get(this);
    registerRunningReactionForOperation({
      target,
      type: 'iterate'
    });
    return runCollectionHandler('size', target);
  }

};
var collectionHandlers$2 = {
  get(target, key, receiver) {
    // instrument methods and property accessors to be reactive
    // eslint-disable-next-line no-prototype-builtins
    target = collectionHandlers$1.hasOwnProperty(key) ? collectionHandlers$1 : target;
    return Reflect.get(target, key, receiver);
  }

};

var globalObj = // eslint-disable-next-line no-new-func
typeof window === 'object' ? window : Function('return this')(); // these stateful built-in objects can and should be wrapped by Proxies if they are part of a store
// simple ones - like arrays - ar wrapped with the normal observable Proxy
// complex ones - like Map and Set - are wrapped with a Proxy of instrumented methods

var handlers = new Map([[Map, collectionHandlers$2], [Set, collectionHandlers$2], [WeakMap, collectionHandlers$2], [WeakSet, collectionHandlers$2], [Object, false], [Array, false], [Int8Array, false], [Uint8Array, false], [Uint8ClampedArray, false], [Int16Array, false], [Uint16Array, false], [Int32Array, false], [Uint32Array, false], [Float32Array, false], [Float64Array, false]]); // some (usually stateless) built-in objects can not be and should not be wrapped by Proxies
// their methods expect the object instance as the receiver ('this') instead of the Proxy wrapper
// wrapping them and calling their methods causes erros like: "TypeError: this is not a Date object."

function shouldInstrument(obj) {
  var constructor = obj.constructor; // functions and objects in the above handlers array are safe to instrument

  if (typeof obj === 'function' || handlers.has(constructor)) {
    return true;
  } // other built-in objects should not be implemented


  var isBuiltIn = typeof constructor === 'function' && constructor.name in globalObj && globalObj[constructor.name] === constructor;
  return !isBuiltIn;
}
function getHandlers(obj) {
  return handlers.get(obj.constructor);
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var wellKnownSymbols = new Set(Object.getOwnPropertyNames(Symbol).map(key => Symbol[key]).filter(value => typeof value === 'symbol')); // intercept get operations on observables to know which reaction uses their properties

function get(target, key, receiver) {
  var result = runProxyHandler('get', target, key, receiver); // do not register (observable.prop -> reaction) pairs for well known symbols
  // these symbols are frequently retrieved in low level JavaScript under the hood

  if (typeof key === 'symbol' && wellKnownSymbols.has(key)) {
    return result;
  } // register and save the (observable.prop -> runningReaction) relation


  registerRunningReactionForOperation({
    target,
    key,
    receiver,
    type: 'get'
  }); // do not violate the none-configurable none-writable prop get handler invariant
  // fall back to none reactive mode in this case, instead of letting the Proxy throw a TypeError

  var descriptor = Reflect.getOwnPropertyDescriptor(target, key);

  if (descriptor && descriptor.writable === false && descriptor.configurable === false) {
    return result;
  } // otherwise return the observable wrapper if it is already created and cached or the raw object


  return observableChild(result, target);
}

function has(target, key) {
  var result = runProxyHandler('has', target, key); // register and save (observable.prop -> runningReaction)

  registerRunningReactionForOperation({
    target,
    key,
    type: 'has'
  });
  return result;
}

function ownKeys$1(target) {
  registerRunningReactionForOperation({
    target,
    type: 'iterate'
  });
  return runProxyHandler('ownKeys', target);
} // intercept set operations on observables to know when to trigger reactions


function set(target, key, value, receiver) {
  // make sure to do not pollute the raw object with observables
  value = proxyToRaw.get(value) || value; // save if the object had a descriptor for this key

  var hadKey = hasOwnProperty.call(target, key); // save if the value changed because of this set operation

  var oldValue = target[key]; // execute the set operation before running any reaction

  var result = runProxyHandler('set', target, key, value, receiver); // do not queue reactions if the target of the operation is not the raw receiver
  // this possible because of prototypal inheritance
  // when the prototype has a setter the set operation traverses the whole prototype chain
  // and calls the set trap on every object until it finds the setter
  // this is undesired, it is enough for us to trigger the reactions in the set trap of
  // the receiver (child) object to avoid duplicate reactions

  if (target !== proxyToRaw.get(receiver)) {
    return result;
  } // queue a reaction if it's a new property or its value changed


  if (!hadKey) {
    queueReactionsForOperation({
      target,
      key,
      value,
      receiver,
      type: 'add'
    });
  } else if (value !== oldValue) {
    queueReactionsForOperation({
      target,
      key,
      value,
      oldValue,
      receiver,
      type: 'set'
    });
  }

  return result;
}

function deleteProperty(target, key) {
  // save if the object had the key
  var hadKey = hasOwnProperty.call(target, key);
  var oldValue = target[key]; // execute the delete operation before running any reaction

  var result = runProxyHandler('deleteProperty', target, key); // only queue reactions for delete operations which resulted in an actual change

  if (hadKey) {
    queueReactionsForOperation({
      target,
      key,
      oldValue,
      type: 'delete'
    });
  }

  return result;
} // return an observable object instance when an observable class is instantiated


function construct(target, args, newTarget) {
  return observable(runProxyHandler('construct', target, args, newTarget));
}

var proxyHandlers$1 = {
  get,
  has,
  ownKeys: ownKeys$1,
  set,
  deleteProperty,
  construct
};

function observable(obj = {}, options) {
  // if it is already an observable or it should not be wrapped, return it
  if (proxyToRaw.has(obj) || !shouldInstrument(obj)) {
    return obj;
  } // if it already has a cached observable wrapper, return it
  // otherwise create a new observable


  return rawToProxy.get(obj) || createObservable(obj, options);
}

function createObservable(obj, options) {
  // if it is a complex built-in object or a normal object, wrap it
  var baseHandlers = getHandlers(obj) || proxyHandlers$1;
  var observable = new Proxy(obj, _objectSpread2(_objectSpread2({}, options === null || options === void 0 ? void 0 : options.proxyHandlers), baseHandlers)); // save these to switch between the raw object and the wrapped object with ease later

  rawToProxy.set(obj, observable);
  proxyToRaw.set(observable, obj); // add custom options to the raw object

  if (options) {
    rawToOptions.set(obj, options);
  } // init basic data structures to save and cleanup later (observable.prop -> reaction) connections


  storeObservable(obj);
  return observable;
} // if observable.prop is an object, wrap it in an observable too
// this is needed to intercept property access on that object too


function observableChild(child, parent) {
  if (typeof child === 'object' && child !== null || typeof child === 'function') {
    // pass the parent's options to the child object
    // this creates a 'deep proxy' which shares custom handlers deeply with its object children
    var options = rawToOptions.get(parent);
    return observable(child, options);
  }

  return child;
}
function isObservable(obj) {
  return proxyToRaw.has(obj);
}
function raw(obj) {
  return proxyToRaw.get(obj) || obj;
}

export { collectionHandlers, isObservable, observable, observe, proxyHandlers, raw, reactionHandlers, unobserve };
