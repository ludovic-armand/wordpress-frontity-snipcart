import { useState, memo, useRef, useMemo, useEffect, Component } from 'react';
import { observe, unobserve, isObservable, raw, observable } from '@frontity/observer-util';
export { unobserve as clearEffect } from '@frontity/observer-util';
import { unstable_batchedUpdates } from './react-platform';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// it is window in the DOM and global in NodeJS and React Native

var isDOM = typeof window !== 'undefined';
var isNative = typeof global !== 'undefined';
var globalObj = isDOM ? window : isNative ? global : undefined;
var hasHooks = typeof useState === 'function';

var isInsideFunctionComponent = false;
var isInsideClassComponentRender = false;
var isInsideFunctionComponentWithoutHooks = false;
var COMPONENT = Symbol('owner component');

function mapStateToStores(state) {
  // find store properties and map them to their none observable raw value
  // to do not trigger none static this.setState calls
  // from the static getDerivedStateFromProps lifecycle method
  var component = state[COMPONENT];
  return Object.keys(component).map(key => component[key]).filter(isObservable).map(raw);
}

function view(Comp) {
  var isStatelessComp = !(Comp.prototype && Comp.prototype.isReactComponent);
  var ReactiveComp;

  if (isStatelessComp && hasHooks) {
    // use a hook based reactive wrapper when we can
    ReactiveComp = props => {
      // use a dummy setState to update the component
      var _useState = useState(),
          _useState2 = _slicedToArray(_useState, 2),
          setState = _useState2[1]; // use a ref to store the reaction


      var reaction = useRef(); // create a memoized reactive wrapper of the original component (render)
      // at the very first run of the component function

      var render = useMemo(() => {
        reaction.current = observe(Comp, {
          scheduler: () => {
            // trigger a new rerender if the component has been mounted
            if (reaction.current.mounted) setState({}); // mark it as changed if the component has not been mounted yet
            else reaction.current.changedBeforeMounted = true;
          },
          lazy: true
        }); // initilalize a flag to know if the component was finally mounted

        reaction.current.mounted = false; // initilalize a flag to know if the was reaction was invalidated
        // before the component was mounted

        reaction.current.changedBeforeMounted = false;
        return reaction.current;
      }, // Adding the original Comp here is necessary to make React Hot Reload work
      // it does not affect behavior otherwise
      [Comp]);
      useEffect(() => {
        // mark the component as mounted.
        reaction.current.mounted = true; // if there was a change before the component was mounted, trigger a
        // new rerender

        if (reaction.current.changedBeforeMounted) setState({}); // cleanup the reactive connections after the very last render of the

        return () => unobserve(reaction.current);
      }, []); // the isInsideFunctionComponent flag is used to toggle `store` behavior
      // based on where it was called from

      isInsideFunctionComponent = true;

      try {
        // run the reactive render instead of the original one
        return render(props);
      } finally {
        isInsideFunctionComponent = false;
      }
    };
  } else {
    var BaseComp = isStatelessComp ? Component : Comp; // a HOC which overwrites render, shouldComponentUpdate and componentWillUnmount
    // it decides when to run the new reactive methods and when to proxy to the original methods

    class ReactiveClassComp extends BaseComp {
      constructor(props, context) {
        super(props, context);
        this.state = this.state || {};
        this.state[COMPONENT] = this; // create a reactive render for the component

        this.render = observe(this.render, {
          scheduler: () => this.setState({}),
          lazy: true
        });
      }

      render() {
        isInsideClassComponentRender = !isStatelessComp;
        isInsideFunctionComponentWithoutHooks = isStatelessComp;

        try {
          return isStatelessComp ? Comp(this.props, this.context) : super.render();
        } finally {
          isInsideClassComponentRender = false;
          isInsideFunctionComponentWithoutHooks = false;
        }
      } // react should trigger updates on prop changes, while easyState handles store changes


      shouldComponentUpdate(nextProps, nextState) {
        var props = this.props,
            state = this.state; // respect the case when the user defines a shouldComponentUpdate

        if (super.shouldComponentUpdate) {
          return super.shouldComponentUpdate(nextProps, nextState);
        } // return true if it is a reactive render or state changes


        if (state !== nextState) {
          return true;
        } // the component should update if any of its props shallowly changed value


        var keys = Object.keys(props);
        var nextKeys = Object.keys(nextProps);
        return nextKeys.length !== keys.length || nextKeys.some(key => props[key] !== nextProps[key]);
      } // add a custom deriveStoresFromProps lifecyle method


      static getDerivedStateFromProps(props, state) {
        if (super.deriveStoresFromProps) {
          // inject all local stores and let the user mutate them directly
          var stores = mapStateToStores(state);
          super.deriveStoresFromProps(props, ...stores);
        } // respect user defined getDerivedStateFromProps


        if (super.getDerivedStateFromProps) {
          return super.getDerivedStateFromProps(props, state);
        }

        return null;
      }

      componentWillUnmount() {
        // call user defined componentWillUnmount
        if (super.componentWillUnmount) {
          super.componentWillUnmount();
        } // clean up memory used by Easy State


        unobserve(this.render);
      }

    }

    ReactiveComp = ReactiveClassComp;
  }

  ReactiveComp.displayName = Comp.displayName || Comp.name; // static props are inherited by class components,
  // but have to be copied for function components

  if (isStatelessComp) {
    Object.keys(Comp).forEach(key => {
      ReactiveComp[key] = Comp[key];
    });
  }

  return isStatelessComp && hasHooks ? memo(ReactiveComp) : ReactiveComp;
}

var taskQueue = new Set();
var scheduler = {
  isOn: false,

  add(task) {
    if (scheduler.isOn) {
      taskQueue.add(task);
    } else {
      task();
    }
  },

  flush() {
    taskQueue.forEach(task => task());
    taskQueue.clear();
  },

  on() {
    scheduler.isOn = true;
  },

  off() {
    scheduler.isOn = false;
  }

};

// until the function is finished running
// react renders are batched by unstable_batchedUpdates
// autoEffects and other custom reactions are batched by our scheduler

function batch(fn, ctx, args) {
  // do not apply scheduler logic if it is already applied from a parent function
  // it would flush in the middle of the parent's batch
  if (scheduler.isOn) {
    return unstable_batchedUpdates(() => fn.apply(ctx, args));
  }

  try {
    scheduler.on();
    return unstable_batchedUpdates(() => fn.apply(ctx, args));
  } finally {
    scheduler.flush();
    scheduler.off();
  }
} // this creates and returns a batched version of the passed function
// the cache is necessary to always map the same thing to the same function
// which makes sure that addEventListener/removeEventListener pairs don't break

var cache = new WeakMap();

function batchFn(fn) {
  if (typeof fn !== 'function') {
    return fn;
  }

  var batched = cache.get(fn);

  if (!batched) {
    batched = new Proxy(fn, {
      apply(target, thisArg, args) {
        return batch(target, thisArg, args);
      }

    });
    cache.set(fn, batched);
  }

  return batched;
}

function batchMethodCallbacks(obj, method) {
  var descriptor = Object.getOwnPropertyDescriptor(obj, method);

  if (descriptor && descriptor.writable && typeof descriptor.value === 'function') {
    obj[method] = new Proxy(descriptor.value, {
      apply(target, ctx, args) {
        return Reflect.apply(target, ctx, args.map(batchFn));
      }

    });
  }
} // batched obj.addEventListener(cb) like callbacks


function batchMethodsCallbacks(obj, methods) {
  methods.forEach(method => batchMethodCallbacks(obj, method));
}

function batchMethod(obj, method) {
  var descriptor = Object.getOwnPropertyDescriptor(obj, method);

  if (!descriptor) {
    return;
  }

  var value = descriptor.value,
      writable = descriptor.writable,
      set = descriptor.set,
      configurable = descriptor.configurable;

  if (configurable && typeof set === 'function') {
    Object.defineProperty(obj, method, _objectSpread2(_objectSpread2({}, descriptor), {}, {
      set: batchFn(set)
    }));
  } else if (writable && typeof value === 'function') {
    obj[method] = batchFn(value);
  }
} // batches obj.onevent = fn like calls and store methods


function batchMethods(obj, methods) {
  methods = methods || Object.getOwnPropertyNames(obj);
  methods.forEach(method => batchMethod(obj, method));
  return obj;
} // do a sync batching for the most common task sources
// this should be removed when React's own batching is improved in the future
// batch timer functions

batchMethodsCallbacks(globalObj, ['setTimeout', 'setInterval', 'requestAnimationFrame', 'requestIdleCallback']);

if (globalObj.Promise) {
  batchMethodsCallbacks(Promise.prototype, ['then', 'catch']);
} // Event listener batching causes an input caret jumping bug:
// https://github.com/RisingStack/react-easy-state/issues/92.
// This part has to be commented out to prevent that bug.
// React batches setStates in its event listeners anyways
// so this commenting this part out is not a huge issue.
// batch addEventListener calls

/* if (globalObj.EventTarget) {
  batchMethodsCallbacks(EventTarget.prototype, [
    'addEventListener',
    'removeEventListener',
  ]);
} */
// this batches websocket event handlers


if (globalObj.WebSocket) {
  batchMethods(WebSocket.prototype, ['onopen', 'onmessage', 'onerror', 'onclose']);
} // HTTP event handlers are usually wrapped by Promises, which is covered above

function createStore(obj, options) {
  return batchMethods(observable(obj, options));
}

function store(obj, options) {
  // do not create new versions of the store on every render
  // if it is a local store in a function component
  // create a memoized store at the first call instead
  if (isInsideFunctionComponent) {
    // useMemo is not a semantic guarantee
    // In the future, React may choose to “forget” some previously memoized values and recalculate them on next render
    // see this docs for more explanation: https://reactjs.org/docs/hooks-reference.html#usememo
    return useMemo(() => createStore(obj, options), []);
  }

  if (isInsideFunctionComponentWithoutHooks) {
    throw new Error('You cannot use state inside a function component with a pre-hooks version of React. Please update your React version to at least v16.8.0 to use this feature.');
  }

  if (isInsideClassComponentRender) {
    throw new Error('You cannot use state inside a render of a class component. Please create your store outside of the render function.');
  }

  return createStore(obj, options);
}

function autoEffect(fn, deps = []) {
  if (isInsideFunctionComponentWithoutHooks) {
    throw new Error('You cannot use autoEffect inside a function component with a pre-hooks version of React. Please update your React version to at least v16.8.0 to use this feature.');
  }

  if (isInsideClassComponentRender) {
    throw new Error('You cannot use autoEffect inside a render of a class component. Please use it in the constructor or lifecycle methods instead.');
  }

  if (isInsideFunctionComponent) {
    return useEffect(() => {
      var reaction = observe(fn, {
        scheduler: scheduler.add
      });
      return () => unobserve(reaction);
    }, deps);
  }

  return observe(fn, {
    scheduler: scheduler.add
  });
}

export { autoEffect, batch, store, view };
//# sourceMappingURL=bundle.js.map
